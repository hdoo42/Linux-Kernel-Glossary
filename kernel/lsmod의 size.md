page 단위로 이루어짐. 

4KiB 단위로 쪼개지는데, 아주 최소한의 모듈로 3페이지는 잡아먹어서 12288로 표기되는 경우 많음. (3페이지)

## 왜 12288이 “최소처럼” 많이 보이나

### 1) 페이지 단위 할당 + 정렬(alignment)

- 커널이 모듈 코드를 메모리에 올릴 때, 내부적으로 **페이지 단위(4 KiB)** 로 잡고
    
- 모듈의 **text/[[rodata]]/data/[[bss]], per-cpu, 메타데이터** 등이 섹션별로 나뉘며 정렬 조건을 타서
    
- 실제 내용이 몇 KB여도 **올림(round-up)** 되어 **여러 페이지**를 차지합니다.
    
- “아주 작은 모듈”들이 **3페이지(12 KiB)** 근처로 뭉쳐 보이는 일이 흔합니다.
    

> 8 KiB(2페이지)도 가능은 한데, 섹션/정렬/메타데이터 때문에 12 KiB가 “바닥값처럼” 자주 관측됩니다.

### 2) lsmod의 Size는 “파일 크기”가 아님

- `lsmod`의 Size는 보통 `cat /proc/modules`의 size 값인데,
    
- 이건 **.ko 파일의 바이트 수**가 아니라, **커널이 로드 후 차지한다고 보는 모듈의 메모리 [[footprint]](대략치)** 입니다.
    
- 그래서 “모듈 소스가 작아도” Size가 동일한 구간으로 뭉칠 수 있어요.
    

### 3) 같은 계열의 아주 작은 “헬퍼/드라이버 조각”이 많다

- 특정 기능을 쪼개서 모듈화하면(예: netfilter, fs helper, crypto helper 등)
    
- 각각이 작아도 로드 단위가 모듈이니 **비슷한 최소 점유량**을 반복적으로 보게 됩니다.