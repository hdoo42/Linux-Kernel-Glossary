리눅스 커널 프로그래밍을 하시다 보면 가장 자주 마주치게 될 함수 중 하나가 바로 `kzalloc`입니다. 한마디로 정의하자면 **"메모리를 할당한 뒤, 그 공간을 0으로 싹 비워주는(초기화하는) 함수"**라고 할 수 있습니다.

---

## 1. `kzalloc`의 핵심 개념

`kzalloc`은 `kmalloc`과 거의 똑같지만, 이름 중간에 있는 **'z'**가 **Zero**를 의미합니다.

- **역할:** 물리적으로 연속된 메모리 공간을 할당하고, 할당된 공간의 모든 비트를 0으로 초기화합니다.
    
- **비교:**
    
- `kmalloc`: 메모리를 할당만 합니다. 이전 사용자가 남긴 "쓰레기 값(Garbage Value)"이 들어있을 수 있습니다.
        
    - `kzalloc`: 메모리 할당 후 즉시 `memset(ptr, 0, size)`를 수행하는 것과 같습니다.
        

## 2. 함수 프로토타입

C

```
void *kzalloc(size_t size, gfp_t flags);
```

- **`size`**: 할당받고 싶은 메모리의 크기 (바이트 단위).
    
- **`flags`**: 메모리 할당 시의 옵션 (어떤 방식으로 할당할지 결정).
    
    - `GFP_KERNEL`: 가장 일반적인 플래그. 메모리가 부족하면 프로세스가 잠들 수(sleep) 있습니다.
        
    - `GFP_ATOMIC`: 인터럽트 핸들러 등 잠들면 안 되는 상황에서 즉시 할당을 시도합니다.
        

---

## 3. 왜 `kzalloc`을 즐겨 쓸까요?

단순히 `kmalloc`을 써도 될 것 같지만, 커널에서는 `kzalloc` 사용을 권장하는 경우가 많습니다.

1. **안전성 (Security):** 이전에 해당 메모리 영역을 썼던 다른 프로세스의 데이터(비밀번호, 키 등)가 남아있을 수 있는데, 이를 0으로 밀어버림으로써 정보 유출을 방지합니다.
    
2. **버그 예방:** 구조체를 할당받았을 때, 따로 초기화하지 않은 멤버가 0(NULL)인 것을 보장받을 수 있어 예기치 않은 오작동을 줄여줍니다.
    
3. **코드 간결성:** `kmalloc` 호출 후 따로 `memset`을 호출할 필요가 없어 코드가 깔끔해집니다.
    

---

## 4. 간단한 사용 예시

커널 모듈 내에서 특정 구조체를 위해 메모리를 할당하는 예시입니다.

C

```
struct my_device_data {
    int id;
    char name[32];
    void *private_data;
};

struct my_device_data *data;

// 메모리 할당 + 0으로 초기화
data = kzalloc(sizeof(*data), GFP_KERNEL);

if (!data) {
    return -ENOMEM; // 메모리 할당 실패 처리
}

// data->id는 이미 0, data->private_data는 이미 NULL인 상태가 보장됨
```

---

### 요약하자면

> **`kzalloc` = `kmalloc` + `memset(0)`**
