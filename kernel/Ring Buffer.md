
### 1. 링 버퍼(Ring Buffer)가 뭔가요?

링 버퍼는 **고정된 크기**의 메모리 공간을 마치 원처럼 끝과 끝을 연결해서 사용하는 자료구조입니다.

- **동작 방식:** 데이터를 순차적으로 채우다가 버퍼가 꽉 차면, 다시 **처음으로 돌아가서 가장 오래된 데이터를 덮어씁니다.**
    
- **특징:** 데이터가 무한히 늘어나지 않도록 메모리 사용량을 엄격하게 제한합니다.
    

### 2. 왜 굳이 이렇게 동작하나요? (3가지 핵심 이유)

#### ① 시스템 안정성 (Memory Management)

커널은 시스템의 심장부입니다. 만약 로그가 쌓인다고 메모리를 무한정 잡아먹으면 로그를 남기려다 시스템이 뻗어버리는 배보다 배꼽이 더 큰 상황이 발생하겠죠? 링 버퍼는 **로그의 최대 크기를 미리 정해두어** 메모리 부족 사태를 방지합니다.

#### ② 고성능 및 비차단 (High Performance)

`printk`는 커널 어디서든(심지어 아주 급박한 인터럽트 상황에서도) 호출될 수 있어야 합니다. 링 버퍼는:

- 메모리를 새로 할당받을 필요가 없습니다.
    
- 구조가 단순해서 쓰기 작업이 매우 빠릅니다.
    
- 로그를 기록하는 쪽(커널)과 읽는 쪽(사용자)의 속도 차이를 완충해 주는 훌륭한 창고 역할을 합니다.
    

#### ③ 최신 정보 우선순위

시스템 장애가 발생했을 때 우리에게 필요한 건 "3일 전의 평온했던 로그"가 아니라 "방금 전 시스템이 왜 터졌는지"에 대한 기록입니다. 링 버퍼의 **오래된 기록 덮어쓰기** 방식은 자연스럽게 가장 최신 정보를 유지해 줍니다.


### 3. 어떻게 확인하나요?

커널이 `printk`로 링 버퍼에 열심히 적어둔 메시지를 우리는 보통 **`dmesg`** 명령어로 꺼내 봅니다.

- `dmesg`: 버퍼에 쌓인 내용을 출력합니다.
    
- `dmesg -w`: 실시간으로 커널 로그가 올라오는 것을 지켜볼 수 있습니다. (마치 `tail -f`처럼요!)
    

> **참고:** 버퍼의 크기는 커널 설정(`CONFIG_LOG_BUF_SHIFT`)에 따라 다르지만, 보통 수백 KB에서 수 MB 정도로 설정됩니다.