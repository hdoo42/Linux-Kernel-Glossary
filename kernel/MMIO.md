**CPU가 하드웨어 장치를 제어할 때 별도의 복잡한 통신 프로토콜 명령어를 매번 만드는 대신, 익숙한 메모리 읽기/쓰기(Load/Store) 방식을 그대로 활용하여 장치와 데이터를 주고받기 위함입니다.**

---

### MMIO(Memory-Mapped I/O)의 구현 (The How)

**MMIO**는 하드웨어의 레지스터나 메모리를 CPU의 **물리 주소 공간(Physical Address Space)** 의 특정 영역에 매핑하는 방식입니다. CPU 입장에서 특정 주소에 값을 쓰는 것은 RAM에 데이터를 저장하는 것과 문법적으로 동일하지만, 실제로는 그 신호가 RAM이 아닌 그래픽 카드(GPU)나 네트워크 카드(NIC)로 전달됩니다.


아 그러니까 CPU입장에서는 똑같은 동작(메모리에 쓰기)을 수행할 뿐이지만(API 추상화) -> 내부 동작이 사실 RAM이 아니라 다른 장치로 전달되는거구나. 


#### 2. 데이터 흐름의 시각화 (State Transformation)

CPU가 네트워크 카드의 상태를 확인하기 위해 `0xC000_1000` 주소를 읽는 과정을 단계별로 살펴봅시다.

1. **CPU 명령어 실행**: `MOV EAX, [0xC000_1000]` 명령어가 실행됩니다.
    
2. **주소 버스 전송**: CPU는 주소 버스에 `0xC000_1000` 신호를 태워 보냅니다.
    
3. **주소 디코딩 (Address Decoding)**: 메인보드의 칩셋(Memory Controller)이 주소를 확인합니다. "이 주소는 RAM 범위가 아니라 PCIe 1번 슬롯에 할당된 범위네?"라고 판단합니다.
    
4. **라우팅**: 칩셋은 해당 요청을 RAM이 아닌 특정 하드웨어 장치(NIC)로 경로를 변경합니다.
    
5. **장치 응답**: 네트워크 카드는 자신의 상태 레지스터 값을 데이터 버스에 올립니다.
    
6. **완료**: CPU는 이 값을 마치 RAM에서 읽어온 것처럼 `EAX` 레지스터에 저장합니다.