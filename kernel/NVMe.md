자기 디스크(HDD)에 맞추어 설계된 레거시 프로토콜은 플래시 메모리의 빠른 처리성능을 온전히 살려내지 못했습니다. 프로토콜이 I/O의 병목을 만들었죠. 그래서 플래시 메모리의 성능을 최대한 살릴 수 있도록 새롭게 설계된 초고속 저장 장치 통신 규격이 바로 NVMe(Non-volatile Memory Express)입니다. 

### 1. [[PCIe]] 버스로의 직접 연결

기존 SATA 방식은 CPU → 칩셋([[PCH]]) → SATA 컨트롤러 → SSD라는 복잡한 경로를 거쳤습니다. NVMe는 **PCI Express(PCIe)** 버스에 직접 연결되어 CPU와 직통으로 데이터를 주고받습니다. 이는 지연 시간(Latency)을 획기적으로 줄이며, 대역폭을 비약적으로 상승시킵니다.

### 2. 압도적인 병렬 처리: Multi-Queue

NVMe의 핵심은 큐(Queue) 설계에 있습니다.

- **AHCI (SATA):** 단 1개의 커맨드 큐를 가지며, 큐당 최대 32개의 명령만 쌓을 수 있습니다. 이는 멀티코어 시대에 심각한 병목을 유발합니다.
    
- **NVMe:** 최대 **64,000개(64K)의 큐**를 가질 수 있으며, 각 큐는 다시 **64,000개의 명령**을 담을 수 있습니다.
### 3. I/O 상태 전이 (Submission & Completion)

커널에서 NVMe 장치로 데이터를 요청할 때의 데이터 흐름은 다음과 같습니다.

1. **Submission Queue (SQ) 호스트 메모리 기록:** CPU(호스트)가 수행할 I/O 명령을 메모리에 위치한 SQ에 씁니다.
    
2. **Doorbell Register Write:** CPU가 NVMe 컨트롤러의 **Doorbell Register**를 업데이트하여 "할 일이 있다"고 알립니다. (이 과정은 [[MMIO]]를 통해 이루어집니다.)
    
3. **Controller Fetch:** NVMe 컨트롤러가 호스트 메모리의 SQ에서 명령을 읽어와 플래시 메모리에서 작업을 수행합니다.
    
4. **Completion Queue (CQ) 기록:** 작업이 완료되면 컨트롤러가 결과를 호스트 메모리의 CQ에 씁니다.
    
5. **Interrupt (MSI-X):** 컨트롤러가 CPU에 인터럽트를 발생시켜 작업 완료를 알립니다.
### 4. 명령어 세트의 최적화

AHCI는 HDD의 헤드 위치 제어 등을 위한 복잡한 명령어를 포함하지만, NVMe는 플래시 메모리에 최적화된 단순한 명령어 세트를 사용합니다. 이는 CPU 사이클 소모를 줄여 I/O 처리 효율을 극대화합니다.

## AHCI vs NVMe 비교 요약
| **특징**      | **AHCI (SATA)**        | **NVMe (PCIe)**                    |
| ----------- | ---------------------- | ---------------------------------- |
| **인터페이스**   | SATA (최대 6Gbps)        | PCIe (Gen4 x4 기준 약 64Gbps)         |
| **최대 큐 개수** | 1개                     | 64,000개                            |
| **큐당 명령수**  | 32개                    | 64,000개                            |
| **지연 시간**   | 높음 (Software Overhead) | 매우 낮음 (Direct CPU Path)            |
| **인터럽트 방식** | Single [[MSI]]         | [[Multi-vector MSI-X]] (코어별 할당 가능) |

# Quiz
