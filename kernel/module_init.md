#Q https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h 매크로들 많던데, 특히 module_init을 부르는 다양한 이름의 매크로가 어떻게 실제로 순서를 정의하는지 궁금해. 

리눅스 커널에서 `module_init`과 그 변형된 매크로들이 실행 순서를 결정하는 핵심 원리는 **"링커 섹션(Linker Section)"** 과 **"Initcall 레벨"** 에 있습니다.

단순히 소스 코드상에 적힌 순서대로 실행되는 것이 아니라, 컴파일 시점에 각 함수 포인터를 특정 메모리 영역에 순서대로 배치하고, 부팅 시 커널이 이를 루프를 돌며 차례대로 호출하는 방식입니다.

궁금해하신 내용을 바탕으로 그 내부 메커니즘을 정리해 드립니다.

---

### 1. 매크로의 정체: Initcall 레벨

`include/linux/init.h`를 보면(보통 `module.h`가 이를 포함합니다), `module_init`은 커널이 **내장(Built-in)** 으로 컴파일될 때와 **모듈(External Module)** 로 컴파일될 때 다르게 동작합니다. 질문하신 "순서"는 주로 **내장된 커널 코드**에서 중요합니다.

커널은 초기화 순서를 8단계(0~7)로 나눕니다.

| **레벨** | **매크로 이름**          | **설명**                                |
| ------ | ------------------- | ------------------------------------- |
| 0      | `pure_initcall`     | 의존성이 전혀 없는 가장 기초적인 초기화                |
| 1      | `core_initcall`     | 커널 핵심 기능 초기화                          |
| 2      | `postcore_initcall` | 핵심 기능 직후 초기화                          |
| 3      | `arch_initcall`     | 아키텍처(x86, ARM 등) 특정 초기화               |
| 4      | `subsys_initcall`   | 서브시스템(네트워크, USB 등) 초기화                |
| 5      | `fs_initcall`       | 파일 시스템 초기화                            |
| 6      | `device_initcall`   | **대부분의 장치 드라이버 (일반적인 `module_init`)** |
| 7      | `late_initcall`     | 가장 마지막에 수행되는 초기화                      |

`module_init(fn)` 매크로는 드라이버가 커널에 포함되어 빌드될 경우, 기본적으로 **level 6 (`device_initcall`)** 로 취급됩니다.

### 2. 순서가 정의되는 원리: 링커(Linker)의 역할

매크로를 타고 들어가면 결국 `__attribute__((__section__(".initcallN.init")))` 형태의 코드를 만나게 됩니다.

1. **함수 포인터 저장:** 컴파일러는 이 매크로가 붙은 함수를 실행 파일의 특정 섹션(예: `.initcall6.init`)에 모아둡니다.
    
2. **링커 스크립트:** 리눅스 커널의 링커 스크립트(`vmlinux.lds.S`)는 이 섹션들을 번호 순서대로 메모리에 일렬로 배치합니다.
    
    - `.initcall0.init` 시작 지점
        
    - ...
        
    - `.initcall6.init` (여기 `module_init` 함수들이 모임)
        
    - ...
        
    - `.initcall7.init` 끝 지점
        

결과적으로 커널 이미지 안에는 **실행해야 할 초기화 함수들의 포인터 배열**이 순서대로 예쁘게 정렬되어 들어가게 됩니다.

### 3. 실제로 호출하는 코드: `do_initcalls`

커널 부팅 과정 중 `init/main.c`에 있는 `do_initcalls()` 함수가 실행됩니다. 이 함수는 위에서 만든 포인터 배열의 시작점부터 끝점까지 루프를 돌며 함수를 하나씩 실행합니다.



```C
// 개념적인 흐름
for (level = 0; level <= 7; level++) {
    // 해당 레벨의 섹션에 있는 함수 포인터들을 순서대로 실행
    do_initcall_level(level);
}
```

### 4. 같은 레벨(예: `device_initcall`) 내에서의 순서는?

만약 똑같은 `module_init`을 사용하는 드라이버가 여러 개라면 그들 사이의 순서는 어떻게 될까요?

- **컴파일/링크 순서:** 링커가 오브젝트 파일(`.o`)을 결합하는 순서에 따릅니다. 즉, `Makefile`에서 먼저 나열된 파일의 함수가 메모리상 앞쪽에 위치하게 되어 먼저 실행됩니다.
    
- 하지만 이에 의존하는 것은 위험하므로, 특정 드라이버가 반드시 먼저 실행되어야 한다면 `subsys_initcall`처럼 더 낮은 숫자의 레벨 매크로를 명시적으로 사용합니다.
    

### 요약

1. **다양한 이름의 매크로**는 각각 **우선순위 번호(0~7)** 를 의미합니다.
    
2. `module_init`은 보통 **6번** 레벨입니다.
    
3. 컴파일러와 링커가 이 번호에 맞춰 **함수 주소를 메모리에 순서대로 나열**합니다.
    
4. 커널 부팅 시 **0번부터 7번까지 루프**를 돌며 함수를 호출하기 때문에 순서가 보장됩니다.
    

따라서 특정 하드웨어가 파일 시스템보다 먼저 준비되어야 한다면, 그 하드웨어 드라이버는 `fs_initcall`보다 앞선 레벨의 매크로를 사용하여 순서를 정의하게 됩니다.